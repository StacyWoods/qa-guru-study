1. Пришла фича на тестирование. Какие виды тестирования и в какой последовтельности будешь применять?
    - _тестирование документации - валидация
    - смоук - проверить билд продукта
    - функциональное - работает ли заложенная в фиче функциональность
    - интеграционное - проверю взаимодействие этой фичи между модулями
    - регрессионное - проверить не поломали ли мы уже имеющийся функционал
2. Какие виды тестовой документации ты знаешь? Что должны в себе они содержать?
    - спецификации - описание того, что нужно протестировать в тестовых данных на основе анализа заказчика
    - тест-план - документ, описывающий и регламентирующий перечень работ по тестированию, техники и подходы (ПМИ), стратегию, области отвественности, ресурсы, расписание и ключевые даты
    - тест-кейс - описание процесса проверки функциональности, содержит набор входных данных, условий выполнения, ожидаемых результатов, северити итд
    - баг-репорт -описание найденного дефекта с указанием окружения, предусловий, шагов выполнения и результатов, направленный на содействие устранения дефекта
    - чек-лист - набор идей для тест-кейсов, плана тетсирования, разработки, управления
3. Что такое тест-ран и для чего используется?
    Тестовый прогон/запуск набора тест-кейсов с информацией о том, на какой версии был запуск, о его времени и результате прохождения тестов
4. В чем отличие критичности бага от его приоритетности?
    Критичность - на сколько серьезной является ошибка с точки зрения работоспособности продукта (Blocker, Critical, Major, Minor, Trivial) (QA)
    Приоритетность - как быстро нужно пофиксить баг (High, Medium, Low) (бизнес)
5. В чем отличие валидации от верификации?
    Верификация - проводится практически всегда, выполняется методом проверки характеристик продукции с заданными требованиями, результатом является вывод о соответствии продукции.
        верификация - создали лекарство по требованиям
        - Отвечает на вопрос правильно ли мы делаем продукт и все ли в соответствии с поставленными требованиями
    Валидация — проводится при необходимости, выполняется методом анализа заданных условий применения и оценки соответствия характеристик продукции этим требованиям, результатом является вывод о возможности применения продукции для конкретных условий.
        можно ли их употреблять конкретному человеку
        - Отвечает на вопрос делаем ли мы продукт правильно с точки зрения ожидания потребности пользователей или заказчика от нашего продукта
6. Какие проверки должен в себя вкулючать смоук-тест?
    Включает небольшое количество тестовых сценариев и предназначено для выявления явных ошибок функциональности и выполняет свои основные функции
7. Что такое тестирование критического пути?
    Проверка функциональности, используемой типичными пользователями в повседневной деятельности
8. Что такое исследовательское тестирование и в чем его отличие от свободного?
    Виды тестирования по признаку формальности:
    исследовательское - одновременная разработка тестов и их исполнение
    свободное - без раразработки тестов и документации, основывается на опыте тестировщика
9. Приведи известные тебе техники тест-дизайна и их особенности.
    - анализ граничных условий,
    - разделение на классы эквивалентности,
    - матрица принятия решения (причина-следствие)
    - функциональное тетсирование,
    - monkey-testing,
    - исследовательское тетсирование
10. Опиши процесс тестирования АПИ на примере одного ендпойнта. Опиши проверки по мере необходимости при тестировании.
    Задачи тестирования АПИ:
    - убедиться, что реализация API работает правильно, как и ожидалось - без ошибок!
    - гарантировать, что реализация API работает в соответствии со спецификацией требований (которая позже становится нашей документацией по API).
    - предотвратить регрессий между написанным кодом(merge) и релизом
    ДЕйствия:
    - проверить спецификацию, например через Swagger:
        - эндпоинты правильно именованы;
        - ресурсы и их типы правильно отражают объектную модель;
        - нет отсутствующей или дублирующей функциональности;
        - отношения между ресурсами правильно отражаются в API
    - убедиться, что контракт REST действителен, включая всю семантику, соглашения и принципы HTTP REST.
    - воспроизведу запрос постамном: сам ендпойнт(путь), тип запроса, заголовки, тело запроса, параметры авторизации

    Для каждого запроса API тест должен будет выполнить следующие действия:
    - Проверить корректность кода состояния HTTP.
        Например, создание ресурса должно возвращать 201 CREATED, а запрещенные запросы должны возвращать 403 FORBIDDEN и т. Д.
    - Проверить полезную нагрузку ответа.
        Проверьте правильность тела JSON, имен, типов и значений полей ответа, в том числе в ответах на ошибочные запросы.
    - Проверить заголовки ответа.
        Заголовки HTTP-сервера влияют как на безопасность, так и на производительность.
    - Проверить правильность состояния приложения.
        Это необязательно и применяется в основном к ручному тестированию или когда пользовательский интерфейс или другой интерфейс можно легко проверить.
    - Проверить базовую работоспособность.
        Если операция была завершена успешно, но заняла неоправданно много времени, тест не пройден.

    В этом случае тест-кейсы делятся на следующие общие группы тестовых сценариев:
    - Основные позитивные тесты (прохождение успешного сценария по умолчанию)
    - Расширенное позитивное тестирование с дополнительными параметрами
    - Негативное тестирование с валидными входными данными
    - Негативное тестирование с недопустимыми входными данными
    - Деструктивное тестирование
    - Тесты безопасности, авторизации и доступности
11. Какие инстурменты используешь при тестировании API, UI?
    Swagger, Postman для API
    Selenide для UI
12. Использовал ли мокирование и для чего?
    Когда еще сервис/ендпойнт не готов и идет разработка TDD, тогда сначала мокаем данные.
    Или когда необходимо замокать ответ сервиса или промежуточного метода, сторонней авторизации
13.14. Какие модели разработки знаешь и какое место в них занимает тестирование?
     TDD - Test-driven development,
        ищем тест, за ним пишем код с оглядкой на тест и их валидность, тесты конкретной функциональности
     BDD - Behaviour-driven development,
        Позволяет совместить технические интересы и интересы бизнеса, тесты описываются предметно ориентированным языком, тесты поведения приложения
     DDT - Data-driven testing, или параметризованное тестирование,
        представляет собой методологию, которая используется для описания тестирования, выполняемого с использованием таблицы условий непосредственно в качестве входных данных теста и проверяемых выходных данных
15.20.23. Какие паттерны автоматизации тебе известны? Паттерны разработки, которые можно использовать и в тестирвоании?
    PageObject - скрывают технические детали HTML и CSS за методами с простыми и понятными именами. Don’t Repeat Yourself - за каждую часть логики должен отвечать один кусок кода и не более
    !Fluent/Chain of invocations - возвращение текущего контектста(getter return this) при выполнении каких-либо действий. Код становится более прозрачным и понятным и менее громоздким.
    !Factory/Page Factory - для сокрытия доп инициализационной логики при создании конкретных пейджов
    !Strategy - когда мы хотим иметь несколько реализаций одного и того же – либо последовательностей, либо действий. Мы можем подставлять туда эту реализацию в зависимости от контекста.
    Value Object - Immutable объединение логически связанных параметров (заполнение формы регистрации нужными аттрибутами)
    !Builder - (setter named With()) используем доменные методы для конфигурирования объекта
    Data Provider - позволяет сделать data-driven тесты, где одна и та же тестовая логика выполнялась с разными данными
    Steps - которые используются во фреймворках, тоже паттерн, позволяющий собирать тесты по шагам
16-18. Тестовые фреймоврки. JUnit, TestNg, RestAssured, Cucumber.
    Junit - опенсорсный фреймворк регрессионного тестирования и написания юнит-тестов,
     + поддерживает разные версии Java
     + поддерживается многими IDE
     + выявление ошибок на ранней стадии и удобочитаемость повышают надежность кода
     + адаптирован к Selenium WebDriver
     - не может выполнять тесты зависимостей
    TestNG - является одним из самых популярных и мощных фреймворков Java-тестирования, используемых для интеграционного, функционального и юнит-тестирования
     + Поддержка тестирования зависимостей,
     + Гибкая конфигурация тестов
     + Позволяет создавать и запускать параллельное тестирование нескольких фрагментов кода
     + Во время имплементации тест-кейса можно создавать HTML-отчет
     - TestNG может не подойти, если в проекте не нужна приоритезация тест-кейсов. К тому же, на установку TestNG нужно больше времени
    RestAssured - одна из самых мощных java-библиотек для автоматизации тестирования Rest API
    Cucumber - интсрумент, который позволяет обернуть код тестов читабельными бизнес-спецификациями
    Cucumber + RestAssured используются в связке или по отдельности и используют человекопонятные команды для описание действий, а TestNG и Junit полноценные фреймворки (аналог последнего - это Selenide)
19. Чем отличается явное и неявное ожидание в Selenium? что лучше рименять и когда?
    Implicit Wait - неявное ожидание:
        - действовует на протяжении всего пробега и ожидает указанное время прежде, чем выбросить NoSuchElementException
        - Не устанавливать Implicit Wait равносильно нулевому лимиту времени, и исключение пробросится сразу
    Explicit wait - явное ожидание:
        - используется для ожидания определенного условия, которое должно быть выполнено прежде, чем тест пойдет дальше.
        - ожидание сработает именно там, где оно указано;
        - как и неявному ожиданию, ему необходимо указать лимит времени;
        - ожидает выполнения необходимого условия;
        - ждет завершения Ajax request.
21. Тестовый класс и метод в JUnit. Использование аннтотаций для подготовки тестовых данных.
    @Test – определяет что метод method() является тестовым.
        @Before – указывает на то, что метод будет выполнятся перед каждым тестируемым методом @Test.
        @After – указывает на то что метод будет выполнятся после каждого тестируемого метода @Test
    @BeforeClass – указывает на то, что метод будет выполнятся в начале всех тестов, а точней в момент запуска тестов(перед всеми тестами @Test).
    @AfterClass – указывает на то, что метод будет выполнятся после всех тестов.
    @Ignore – говорит, что метод будет проигнорирован в момент проведения тестирования.
    Для подготовки данных используются аннотации провайдеров совместно с аннтотацией @ParameterizedTest:
        @ValueSource() - например: @ValueSource(strings = {"Discover","People"})
        @CsvSource() - например: @CsvSource(value = {"Explore topics you are interested in|Science and Environment"}, delimiter = '|')
        @EnumSource() - например: @EnumSource(LinkedInMenuItem.class)
        @MethodSource() - например: @MethodSource("getParametrizedData")
22. Писал ли аннтотации и пример использования?
    Собственные аннтоации нужны для комбинирования целого набора аннтоций в свою собственную для удобочитаемости или логического разделения
24. Что такое интерфейс, абстрактный класс и когда лучше что применять?
    Интерфейс
        - только декларирует публичные методы без их реализации,
        - не имеет переменных класса,
        - имплементируется,
        - возможна множественная имплементация,
        - связывает между собой множество разных классов, у которых часто нет ничего общего
    Абстрактный класс
        - как минимум один метод объявлен абстрактным,
        - может содержать реализацию остальных методов,
        - содержит переменные класса,
        - екстендится,
        - только один класс можно наследоваться,
        - создается для группы очень близких друг другу классов.
25. Что такое статика?
    Static - модификатор, применяемый к полю, блоку, методу или внутреннему классу. Данный модификатор указывает на привязку субъекта к текущему классу
    Для использования статических методов/переменных/класса нам не нужно создавать объект данного класса.
    Static поля - это константирование этого поля в рамках класса, каждый объект этого класса будет иметь доступ к общему статическому полю, а не к своему лично.
    Static блока - статичтечский блок предназначен для инициализации внутренних переменных класса.
    Static method - привязан к классу, а не к объекту, может обратиться только к статическим переменным/методам
    Static class - может быть только внутренний класс, этот класс привязан к внешнему классу, и если внешний наследуется другим классом, то этот не будет наследован.
        При этом данный класс можно наследовать, как и он может наследоваться от любого другого класса и имплементировать интерфейс.
    - НЕльзя получить доступ к НЕ статическим членам класса, внутри статического контекста
    - статические поля и методы НЕ потокобезопасны
    - НЕльзя переопределять (Override) статические методы
    - Во время сериализации, также как и transient переменные, статические поля не сериализуются
    + Статический метод можно вызвать, используя тип класса, в котором эти методы описаны.
        Именно поэтому, подобные методы как нельзя лучше подходят в качестве методов-фабрик (factory), и методов-утилит (utility).
        По этой же причине классы-утилиты в Java финализированы (final).
    + статические методы связываются во время компиляции, в отличие от связывания виртуальных или не статических методов, которые связываются во время исполнения на реальном объекте.
        Следовательно, статические методы не могут быть переопределены в Java, т.к. полиморфизм во время выполнения не распространяется на них.
    + Статические поля или переменные инициализируются после загрузки класса в память.
        Порядок инициализации сверху вниз, в том же порядке, в каком они описаны в исходном файле Java класса.
26. Перегрузка и переопределение методов.
    overloading - перегрузка - параметрический полиморфизм - создание одноименного метода с неповторяющейся сигнатурой
    overriding - переопределение - специфическая реализация метода родительского класса, обязан иметь ту же сигнатуру
27. Работа с базами данных.
    JDBC - драйвер не является базой данных
    Hibernate - фреймворк
!28. Интеграция с другими сервисами, на примере интеграции с другими API.
29. Сборщики, что использовал?
    Maven - xml
       > Структура / зависимости проекта определяются файлом pom.xml
       - транзитная зависимость - Когда использование пакета зависит от других пакетов, Maven автоматически импортирует все зависимые пакеты
       + центральный репозиторий
    Gradle - groovy, полноценный я программирования, и как следствие более гиибкая настройка
        > представляет build.gradle
        - для ссылок на подклассы микросервисов и мультипроектов он не так хорош, как Maven
        - нет собственной инфраструктуры (для новых библиотек необходимо писать pom.xml для загрузки в мавен)
        + так же использует мавен репозиторий
        + быстрее
        + Gradle эквивалентен комбинации Maven и Ant(не использовала).
!30. CI/CD. Что использовал при написании pipeline?
31. Репорты, с которыми знаком.
    Allure - фреймворк, позволяющий собирать (allure:serve) и геренировать одинакового вида отчеты на разных языках программирования
    Cовместим с JUnit4 и JUnit5
    Подключение Aspectj:
     - позволяет отлавливать аннотации @Step в последовательности выполняющихся методов
     - перехватить и “проглотить” исключения, записав при этом в лог
     - добавление и маркировка информации о шаге в отчет
!32. Работа с докером. На каком уровне, из тестов и из CI.