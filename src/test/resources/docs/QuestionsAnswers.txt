ПО и его качество:
+ Жизненный цикл ПО (Software Development Life Cycle, SDLC).
    Этапы: концепт, описание требований, дизайн, реализация, тестирование, инсталляция, эксплуатация и поддержка.
+ Каскадная модель разработки ПО (Waterfall model).
    В данной модели разработчики переходят от одного этапа к другому строго последовательно и только после окончания предыдущего.
    Фазы: определение требований, проектирование, кодинг, тестирование и отладка, поддержка.
+ Гибкая методология разработки (Agile).
    Это итеративный подход к управлению проектами и разработке ПО. Разработка сводится к серии коротких циклов (итераций) по 2-3 недели.
    После каждой итерации продукт готов к выпуску. И также после каждого цикла пересматриваются требования на актуальность.
    Примеры: SCRUM, Kanban.
+ SCRUM.
    Одна из гибких методологий. Основные артефакты: Product Backlog, Sprint Backlog, Sprint Goal, Sprint Burndown Chart.
+ Что такое качество ПО?
    Степень близости продукта к ожидаемому результату (требованиям).
+ Quality Assurance.
    Комплекс мероприятий на тему: каким должно быть качество, как достичь данного качества, обеспечение качества, как улучшить качество.
+ Quality Control.
    Действия, которые помогают понять, готово ли ПО к релизу, соответствует ли требованиям.
+ Testing.
    Проверка соответствия между реальным и ожидаемым поведением программы, осуществляемая на конечном наборе тестов, выбранном определенным образом.
    Это одна из техник контроля качества, включающая в себя активности по:
     - планированию работ (Test Management),
     - проектированию тестов (Test Design),
     - выполнению тестирования (Test Execution)
     - и анализу полученных результатов (Test Analysis).
    Это верификация + валидация + поиск ошибок.
+ Verification/Validation.
    Верификация — проводится практически всегда, выполняется методом проверки характеристик продукции с заданными требованиями, результатом является вывод о соответствии продукции.
    Валидация — проводится при необходимости, выполняется методом анализа заданных условий применения и оценки соответствия характеристик продукции этим требованиям, результатом является вывод о возможности применения продукции для конкретных условий.
    Например, лекарство:
    верификация - создали лекарство по требованиям,
    валидация - можно ли их употреблять конкретному человеку.

==================================================
Тестовая документация:
+ Цели тестирования.
    1. Соответствие требованиям.
    2. Очищение от багов
+ Что такое спецификация?
    Текстовый файл с описанием того, что нужно протестировать в тестовых данных. Получается на основе анализа требований заказчика.
+ Что такое требования?
    Это совокупность утверждений относительно программы, которую нужно создать. Могут быть текстовые и графические.
+ Что такое Use Case?
    Это такой формат описания требований, который используют бизнес-аналитики.
    Use case представляет собой законченную последовательность действий пользователя.
    Например: Открыть браузер, ввести логин/пароль. Нажать кнопку. Попасть на страницу Home.
    Use case похож на End-to-End тест кейс.
+ Что такое тест-кейс?
    Текстовое описание процесса проверки функциональности части программы.
    Включает: идентификатор, название, приоритет, компоненты, степы, результат.
+ Что такое тест-план?
    Документ, который описывает весь объем работ по тестированию.
    Включает в себя название, версия/сборка, объект тестирования, стратегия, полезные ссылки, риски, приоритеты, покрытие, инструменты, распределение тест кейсов по персоналу, критерии начала и окончания.
+ Как понять, что тестирование закончено?
    Достигнут дедлайн, процент успешно выполненных тестов, все дефекты исправлены, все тест-кейсы пройдены, бюджет исчерпан.
+ Что такое баг?
    Несоответствие между фактическим и ожидаемым поведением продукта.
+ Жизненный цикл бага.
    Open, In Progress, Ready For QA, QA In Progress, Closed.
    Этап Closed может быть выполнен с разными резолюциями: Fixed, Won't fix, Needs more info.
+ Из каких компонентов состоит баг-репорт?
    Идентификатор, название, версия, окружение, Priority, Severity, шаги + результат, логи/скрины.
+ Priority/Severity.
    Severity - на сколько серьезной является ошибка с точки зрения работоспособности продукта.
    Priority - как быстро надо пофиксить баг.
    Пример высокого Priority и низкого Severity. Опечатка в слове Google на главной странице поисковика.
+ Эффект пестицида.
    Если часто проводить одни и те же тестовые сценарии, то баги перестанут находиться.

==================================================
Виды/уровни тестирования:
+ Уровни тестирования.
    1. Unit тестирование.
    2. Интеграционное
    3. Системное
    4. Acceptance (приемочное) - соответствие требованиям заказчика.
    5. Альфа и бета тестирование
+ Виды тестирования.
    1. Smoke
    2. Functional
    3. Regression
    4. Configuration
    5. UI
    6. Installation
    7. Internationalization & Localization
    8. Performance (Load, Stress, Stability)
    9. Compatibility
    10. Usability
    11. White / Black box
    12. Positive / Negative
    13. Verification / Validation.
+ Тестирование методом черного ящика.
    Не имеем доступ к коду программы. Пример: тестирование UI/UX, тестирование установки.
+ Тестирование методом белого ящика.
    Тестировщик имеет доступ к коду (Unit тестирование). Часто такое тестирование отражает ошибки в коде, а не в функциональном поведении.
+ Тестирование методом серого ящика.
    По-прежнему не имеем доступ к коду, но зато в целом представляем логическую структуру приложения, можем поделить его на модули.
+ Статическое тестирование.
    Анализируем требования и программный код без его запуска.
    Динамическое - запускаем.
+ Функциональное тестирование.
    Проверяем, что ПО выполняет все функции, описанные в спецификации.
    Нефункциональное - то, что не связано с конкретными действиями пользователя. Например, надежность, перформанс, нагрузочное, безопасность.
+ Тестирование на основе рисков.
    Определяем самые важные части системы. Устанавливаем порядок их тестирования. Тестим.
+ Что такое тестирование End-to-End (сквозное)?
    Тестирование с точки зрения наиболее часто выполняющихся пользовательских сценариев.
+ Позитивное тестирование.
    Проверка на то, что система функциональна. Такой подход также известен как "Тест на прохождение".
    Поведение пользователя не выходит за рамки "нормальности".
+ Негативное тестирование.
    Выдает ли система ошибку, когда должна / не должна. Пример. Вводим неверный пароль с запрещенными символами.
    Жмем кнопку несколько раз. Негативное тестирование позволяет найти наибольшее количество багов.
+ Деструктивное тестирование.
    Глубокая форма негативного тестирования, когда мы намеренно пытаемся сломать API, чтобы проверить его надежность
    Например, отправляя заведомо большое тело запроса в попытке переполнить систему
+ Monkey testing.
    Тестирование без какого-либо плана, тестирование выборочных мест.
+ Тестирование производительности.
    Нагрузочное(высокая нагрузка), стресс-тестирование(ограниченные ресурсы) и тестирование стабильности(тестируем в течение промежутка времени).
+ Что такое тестирование глобализации (Globalization Testing)?
    Возможность запуска приложения вне зависимости от его географической и культурной среды.
+ Bucket Testing, или A/B-тестирование.
    Две версии сайта запускаются на одной или нескольких веб-страницах, чтобы определить разницу в кликах.
+ Test-driven development (Разработка через тестирование, TDD).
    Пишем тест, за ним пишем код, далее делаем рефакторинг с постоянной оглядкой на то, что ранее пройденные тесты должны по-прежнему проходить.
+ Behaviour-driven development (BDD).
    Позволяет совместить технические интересы и интересы бизнеса - используем предметно ориентированный язык, понятный и менеджерам и программистам.
    Пример такого языка: Gherkin.
+ API tests.
    Тесты API проходят быстро, обеспечивают высокую рентабельность инвестиций и упрощают проверку бизнес-логики, безопасности, соответствия и других аспектов приложения.
    Задачи тестирования АПИ:
        - убедиться, что реализация API работает правильно, как и ожидалось - без ошибок!
        - гарантировать, что реализация API работает в соответствии со спецификацией требований (которая позже становится нашей документацией по API).
        - предотвратить регрессий между написанным кодом(merge) и релизом
        Действия:
        - проверить спецификацию, например через Swagger:
            - эндпоинты правильно именованы;
            - ресурсы и их типы правильно отражают объектную модель;
            - нет отсутствующей или дублирующей функциональности;
            - отношения между ресурсами правильно отражаются в API
        - убедиться, что контракт REST действителен, включая всю семантику, соглашения и принципы HTTP REST.
        Для каждого запроса API тест должен будет выполнить следующие действия:
        - Проверить корректность кода состояния HTTP. Например, создание ресурса должно возвращать 201 CREATED, а запрещенные запросы должны возвращать 403 FORBIDDEN и т. Д.
        - Проверить полезную нагрузку ответа. Проверьте правильность тела JSON, имен, типов и значений полей ответа, в том числе в ответах на ошибочные запросы.
        - Проверить заголовки ответа. Заголовки HTTP-сервера влияют как на безопасность, так и на производительность.
        - Проверить правильность состояния приложения. Это необязательно и применяется в основном к ручному тестированию или когда пользовательский интерфейс или другой интерфейс можно легко проверить.
        - Проверить базовую работоспособность. Если операция была завершена успешно, но заняла неоправданно много времени, тест не пройден.

+ Пирамида тестирования:
    ----- unit tests
    ---- component tests
    --- integration tests
    -- api tests
    - gui tests

==================================================
Техники составления тест кейсов:
+ Что такое матрица тестирования?
    Матрица, в которой колонки - это требования к системе, столбцы - тест кейсы. Такая матрица является одним из способов оценки покрытия.
+ Техники составления тест-кейсов.
    - Классы эквивалентности,
    - проверка граничных значений,
    - таблица принятия решений,
    - pairwise,
    - диаграммы изменения состояний.
+ Классы эквивалентности.
    Классы эквивалентности - данные, на которых (как мы ожидаем) программа будет вести себя одинаково.
    Этапы:
    1. Разбиваем входные данные на классы эквивалентности.
    2. Выбираем одного представителя из каждого класса.
    3. Выполняем тест.
+ Проверка граничных значений.
    Это методология составления тест-кейсов, при которой мы тестируем на значениях, близких к границам допустимых диапазонов.
    Проверяем 3 значения: значение перед границей, граничное значение, значение после границы.
    Этапы:
    1. Выделяем классы эквивалентности.
    2. Определяем граничные значения классов.
    3. Проводим тесты для значения до, на, после границы.
+ Таблица принятия решений.
    Этапы:
    1. В колонку записываем Условия, ниже Действия.
    2. Считаем количество столбцов для Выполнения / Невыполнения условий. <количество_столбцов> = 2 в степени <количество_условий>.
    Например, если имеем 3 условия, то добавляем в таблицу 8 столбцов.
    3. Заполняем столбцы/строки.
    Первая строка: True, False, True, False, True, False, True, False.
    Вторая строка: True, True, False, False, True, True, False, False.
    Третья строка: True, True, True, True, False, False, False, False.
    4. Отсеиваем лишние проверки условий (например, если Условие 1 ложно, то Условие 3 проверять нет смысла).
    5. Отсеиваем лишние столбцы (дублируются условия).
+ Попарное тестирование (Pairwise testing).
    Значения каждого параметра должны встретиться с всеми значениями другого параметра.
    Этапы:
    - Предположим, что имеем 3 входных параметра, каждый из которых может принимать 2 значения.
    - Перебираем все комбинации 1го параметра со 2м (значение первого параметра фиксируем).
    - Перебираем 1й параметр с 3м (значение 2го фиксируем).
    - Перебираем 2й параметр с 3м (значение 1го параметра фиксируем).
    - Из полученных 12 строк удаляем дубликаты, получаем 7 кейсов.
    - Проводим дальнейшие оптимизации, если это возможно/необходимо.
+ Диаграмма изменения состояний.
    Этапы:
    - Составляем диаграмму состояний объекта.
    - Составляем списки всех состояний и всех действий.
    - Комбинируем все действия и все состояния.
    - Из полученных комбинаций выделяем 3 группы тестов: позитивные, негативные, невалидные.
    - Удаляем невалидные.

==================================================
Тестируем формы:
Важный момент: для клиент-серверных приложений валидация форм делится на два типа:
1. Валидация со стороны клиента
2. Валидация со стороны клиента
То есть валидацию нужно проверять и для клиента и для сервера.

Элементы форм:
1. Текстовые поля и области (Text Field, Text Area)
Проверки:
- Обязательность полей (оставляем пустыми поочередно и вместе)
- Вводим минимально/максимально допустимые значения (на 1 меньше, само значение и на 1 больше).
- Ввод разного типа символов (латиница, кириллица, Unicode, цифры, спецсимволы, пробелы в разных местах строки, html тэги, данные из буфера обмена).

2. Ссылки (Links)
Проверки:
- Префиксы: пустой, разные протоколы (http, https, ftp).
- Далее аналогично текстовым полям.

3. Чек боксы (Check box)
Проверки:
- Выбираем разное количество(ничего, один, два, все).
- Наличие галочки Check all (для большого количества чек боксов).
- Область возле чек-бокса тоже должна быть кликабельной.

4. Radio button
Проверки:
- Один всегда выбран
- Не могут быть выбраны оба
- Область возле кнопки тоже должна быть кликабельной.

5. Загрузкаа файла (File uploader)
Проверки:
- Не выбираем файл
- Загрузка файлов разных размеров (меньше, ровно по ограничению, больше ограничения на размер, очень маленький файл)
- Валидность формата файла
- Как работает, если можно вводить в поле путь до файла
- Далее аналогично текстовым полям

6. Телефон, Почта (Phone, Email)
Проверки:
- Проверяем как текстовые поля
- Наличие плейсхолдера (подсказки).
- Отдельно проверяем допустимые спецсимволы (+, (), @, @@,)
- Наличие маски

7. Логин, пароль (Login, Password)
Проверки:
- Проверяем как текстовые поля
- Требования к сложности пароля (содержит/не содержит все/одно условия)

8. Выпадающий список (Dropdown)
Проверки:
- Проверяем как текстовые поля
- Выбираем разные элементы.
- Поиск по элементам (вводим первую букву - должен выбирать соответствующий элемент)
- Сортировки
- Отдельно проверяем, если этот список запоминает предыдущие значения

==================================================
ООП:

+ Определение ООП.
    Методология, в которой программа - совокупность объектов, каждый из которых - экземпляр класса, а классы образуют иерархию наследования.
+ Класс.
    Шаблон для создания объектов, обеспечивающий начальные значения состояний (инициализация полей и реализация методов).
+ Объект.
    Экземпляр класса, имеющий определенные поля (атрибуты) и операции над ними (методы).
+ Поля, методы.
    Поле - свойство объекта, метод - функция.
+ Абстрактный класс.
    Класс, для которого не реализован ОДИН или БОЛЬШЕ методов.
    Особенности:
    1. Это класс, для которого нельзя создать объект.
    2. Может содержать как обычные, так и абстрактные поля и методы.
    3. Не допускает множественное наследование.
+ Абстрактный метод (виртуальный метод).
    Метод класса, реализация для которого отсутствует.
+ Интерфейс.
    Это абстрактный класс, у которого НИ ОДИН метод не реализован, все они публичные и нет переменных класса.
    Любой интерфейс - это абстрактный класс, но не наоборот.
+ Абстракция.
    1. Выделяет главные свойства предмета.
    2. Отбрасывает второстепенные характеристики.
+ Инкапсуляция.
    Прячет внутреннюю реализацию объекта, все взаимодействия - через интерфейс.
+ Наследование.
    Создаем класс на основе существующего. Потомок наследует поля и методы родителя + добавляет свои.
    Выражает отношение "Является" (например, Mercedes является машиной).
+ Композиция.
    Класс, известный как составной, содержит объект другого класса, известный как компонент.
    Выражает отношение "Имеет" (Например, машина имеет двигатель).
+ Чем отличаются Наследование и Композиция?
    Общее: позволяют повторно использовать существующий код.
    Отличия:
    - Наследование требует расширения наследуемого класса.
    - Во многих языках запрещено множественное Наследование. А значит нельзя переиспользовать функционал нескольких разных классов. В Композиции- можно.
    - При Композиции легче писать юнит тесты - делаем заглушки.
    - При Наследовании это сделать сложнее - не получится заменить заглушкой родительский класс.
    - При наследовании класс-потомок зависит от функционала класса-родителя. Ломается родитель - ломается и потомок.
    Итог: когда нужно использовать класс как таковой без каких-либо изменений, рекомендуется Композиция, а когда нужно изменить поведение метода в другом классе, рекомендуется Наследование.
+ Полиморфизм.
    Поддержка нескольких реализаций на основе общего интерфейса.
    Т.е. позволяет перегружать одноименные методы родительского класса в классах-потомках

==================================================
Алгоритмы:

+ Сортировка. Пузырьком.
    Проходимся по элементам массива и попарно сравниваем. Если левый больше правого - меняем местами.
+ Сортировка. Вставка.
    Делим массив на две части (левую и правую). Левую часть считаем отсортированной.
    Изначально первый элемент массива оставляем в левой части, все остальное относим к правой (не отсортированной).
    Начинаем перемещаться по не отсортированной части.
    Берем первый элемент, и попарно сравнивая с соседними, ищем ему место в отсортированной части.
    Например, имеем массив [ 4 6 2 1 ].
    Выполняем сортировку:
    - Делим на 2 части: [ 4 | 6 2 1 ].
    - Берем элемент 6 и ставим его на подходящее место в отсортированной части: [ 4 6 | 2 1 ].
    - Ставим на свое место элемент 2: [ 2 4 6 | 1 ].
    - Ставим на свое место элемент 1: [ 1 2 4 6 ].
+ Сортировка. QuickSort.
    Основывается на выборе опорного элемента и дальнейшей сортировке элементов на группы: меньше / равны / большего опорного.
        В качестве опорного элемента эффективно выбирать медианное значение.
        Медианное значение - значение, которое находится в середине отсортированного списка.
    Алгоритм:
    - Выбираем опорный элемент.
    - Перераспределяем элементы относительно опорного - слева меньше, справа больше.
    - Рекурсивно выполняем п 1 и п 2 на полученных подмассивах.
    - Рекурсия не применяется, если в подмаслила остался 1 элемент или вообще ни одного.

==================================================
Клиент-серверная архитектура:
+ Компоненты Web-приложения.
    1. Серверная часть: Логика (Java, Python, C#, C++) + БД.
    2. Клиентская часть: HTML, CSS, JavaScript. 3. Протокол: HTTP, HTTPS.
+ В чем разница между протоколами HTTP и HTTPS?
    HTTPS является расширением протокола HTTP с надстройкой шифрования.
    HTTP использует порт 80,
    HTPPS - 443.
+ Структура HTTP сообщения.
    Стартовая строка, заголовки, тело сообщения.
+ Типы HTTP запросов.
    OPTIONS, GET, POST, PUT, PATCH, DELETE.
+ Прокси-сервер.
    Промежуточный сервер между компьютером пользователя и конечным пользователем.
    Повышает уровень конфиденциальности и позволяет обходить региональные блокировки.
+ API (Application programming interface).
    Контракт, который предоставляет программа. «Ко мне можно обращаться так и так, я обязуюсь делать то и это».
+ REST API.
    API, соответствующий принципам архитектурного стиля REST (например, отделение сервера от клиента, отсутствие сохранения состояния).
+ Linux Команды:
    sudo, lsof, ps, kill, curl, wget, ssh, find, grep, awk, head, tail, less, pwd, ls, mkdir, rm, cat, touch, chown, cp, mv, ln
+ Git:
    init, clone, status, add, commit, branch, checkout, log, diff, restore, rm, checkout, revert, merge, cherry-pick, rebase, fetch, pull, push.

==================================================
Компьютерные сети:
+ Пятиуровневая структура сети (TCP/IP).
    Физический уровень. Сигналы в кабеле.
    Канальный уровень. Протоколы: Ethernet, WiFi. Идентификация по MAC адресам.
    Сетевой уровень. Протоколы: IPv4 и IPv6. Идентификация по IP адресам.
    Транспортный уровень. Протоколы: TCP/UDP. Идентификация по порту(80, 8080 и т д).
    Уровень приложений. Протоколы: HTTP, SSH, FTP.
+ Сетевые сервисы.
    DNS (Domain Name System).
        Хранит сопоставление доменных имен и их IP адресов.
            Например, 8.8.8.8 - IP адрес для доменного имени google.com.
        Так же необходим для кэширования ранее используемых адресов (эти адреса могли быть получены от более крупного регионального DNS сервера).
        Часто к одному доменному имени могут еще привязываться поддомены и почтовые сервера, которые в свою очередь, могут иметь другие IP адреса.
        В DNS сервере есть файлы, в которых хранятся все необходимые связи между доменным именем и IP-адресами.
        Написанное в таком файле называется описанием DNS-зоны. Описание выполняется в помощью разных типов записей: A, MX, CNAME и т д.
    NAT (Network Address Translation).
        Переводит частный адрес (адрес в локальной сети) в общедоступный публичный (адрес в интернете).
        Несколько устройств в локальной сети пользуются одним публичным адресом.
    DHCP (Dynamic Host Configuration Protocol).
        DHCP сервер выдает машинам в сети динамические IP адреса из заданного диапазона.
        Помимо IP адреса также присылает маску подсети, адрес шлюза, адреса DNS серверов.
    LAN/WAN.
        Локальная/Глобальная сети.
    VPN (Private Virtual Network).
        Позволяет объединить в одну частную сеть несколько локальных сетей через Интернет.
